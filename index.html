<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Anonostr | Anonymous Nostr Client</title>
    <meta name="description"
        content="Send anonymous notes to the Nostr network with Anonostr. Each note submission generates a new key pair that's securely burned after single use furthering anonymity.">
     <!-- IPFS -->
     <link rel="alternate" href="ipfs://Qmf3C1FUic6XQguUXqzHtoVrQv8HsuqvNg8pPVfNeFceNm" title="Access via IPFS">
     <meta name="ipfs-hash" content="Qmf3C1FUic6XQguUXqzHtoVrQv8HsuqvNg8pPVfNeFceNm">
     <!-- Open Graph Meta Tags -->
     <meta property="og:title" content="Anonostr | Anonymous Nostr Note Sender">
     <meta property="og:description"
         content="Send anonymous notes to the Nostr network with Anonostr. Each note submission generates a new key pair that's securely burned after single use furthering anonymity.">
     <meta property="og:image" content="https://anonostr.com/images/anonostr-og.png">
     <meta property="og:url" content="https://anonostr.com">
     <meta property="og:type" content="website">
     <link rel="icon" href="./images/anonostr-icon.png" type="image/png">
     <link rel="canonical" href="https://anonostr.com/">
     <link rel="manifest" href="/manifest.json">
     <meta name="theme-color" content="#007bff">
     <meta name="mobile-web-app-capable" content="yes">
     <meta name="apple-mobile-web-app-capable" content="yes">
     <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
     <meta name="apple-mobile-web-app-title" content="Anonostr">
     <link rel="apple-touch-icon" href="./images/anonostr-icon.png">
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
            background-color: #f4f4f4;
            color: #333;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        .sidebar {
            width: 300px;
            background-color: #fff;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        .main-content {
            flex: 2;
            padding: 20px;
            overflow-y: auto;
            background-color: #f4f4f4;
        }

        .replies-column {
            width: 300px;
            background-color: #fff;
            padding: 20px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            overflow-y: auto;
        }

        .hero-section {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            gap: 20px;
        }

        .hero {
            width: 30%;
            height: auto;
            object-fit: cover;
            border-radius: 8px;
        }

        .desc-section {
            margin-bottom: 20px;
        }

        h1 {
            flex: 1;
            text-align: center;
            margin: 0;
            font-size: 24px;
        }

        @media (min-width: 601px) {
            h1 {
                font-size: 32px;
            }

            .sidebar {
                display: flex;
                flex-direction: column;
                justify-content: space-between;
                height: 100vh;
                box-sizing: border-box;
            }

            form {
                display: flex;
                flex-direction: column;
                flex-grow: 1;
            }

            textarea {
                flex-grow: 1;
                padding: 10px;
                margin-bottom: 15px;
                border-radius: 4px;
                border: 1px solid #ccc;
                min-height: 150px;
                box-sizing: border-box;
                overflow: auto;
                resize: vertical;
            }

            footer {
                text-align: center;
                padding: 20px 0;
                background-color: #fff;
                position: sticky;
                bottom: 0;
                width: 100%;
                margin-top: auto;
            }
        }

        @media (max-width: 600px) {
            .hero-section {
                flex-direction: column;
                align-items: center;
            }

            .hero {
                width: 20vw;
                height: auto;
            }

            h1 {
                text-align: center;
                margin-top: 10px;
                font-size: 24px;
            }

            .main-content {
                display: none;
            }

            .replies-column {
                display: none;
            }

            .sidebar {
                width: 100%;
                height: 100vh;
                box-shadow: none;
                padding: 20px;
                overflow-y: auto;
            }

            textarea {
                padding: 10px;
                margin-bottom: 15px;
                border-radius: 4px;
                border: 1px solid #ccc;
                min-height: 150px;
                box-sizing: border-box;
                overflow: auto;
                resize: vertical;
                width: 100%;
            }
        }

        label {
            margin-bottom: 5px;
            font-weight: bold;
        }

        textarea,
        input {
            font-size: 16px;
        }

        button {
            padding: 10px 15px;
            background-color: #7f00ff;
            color: #fff;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s ease;
            position: relative;
        }

        button:hover {
            background-color: indigo;
        }

        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }

        .spinner {
            border: 2px solid #f3f3f3;
            border-radius: 50%;
            border-top: 2px solid #007bff;
            width: 14px;
            height: 14px;
            animation: spin 1s linear infinite;
            position: absolute;
            top: 50%;
            left: 50%;
            margin-top: -7px;
            margin-left: -7px;
            display: none;
        }

        @keyframes spin {
            0% {
                transform: rotate(0deg);
            }

            100% {
                transform: rotate(360deg);
            }
        }

        .note {
            margin-top: 20px;
            padding: 10px;
            border-radius: 4px;
            display: none;
        }

        .note.success {
            background-color: #d4edda;
            color: #155724;
        }

        .note.error {
            background-color: #f8d7da;
            color: #721c24;
        }

        .note.warning {
            background-color: #fff3cd;
            color: #856404;
        }

        .note a {
            color: #007bff;
            text-decoration: none;
        }

        .note a:hover {
            text-decoration: underline;
        }

        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin-bottom: 20px;
        }

        .checkbox-container {
            display: flex;
            align-items: center;
            position: relative;
        }

        .checkbox-container input {
            margin-right: 10px;
            vertical-align: middle;
        }

        .checkbox-container label {
            margin: 0;
            vertical-align: middle;
            font-size: 12px;
        }

        .tooltip {
            margin-left: 8px;
            cursor: pointer;
            font-size: 14px;
            display: inline-flex;
            align-items: center;
            position: relative;
            z-index: 1000;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #333;
            color: #fff;
            text-align: center;
            border-radius: 6px;
            padding: 5px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            left: 50%;
            transform: translateX(-50%);
            opacity: 0;
            transition: opacity 0.3s;
        }

        .tooltip .tooltiptext::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 50%;
            transform: translateX(-50%);
            border-width: 5px;
            border-style: solid;
            border-color: #333 transparent transparent transparent;
            z-index: 1000;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
            z-index: 1000;
        }

        @media (min-width: 601px) {
            .checkbox-group {
                flex-direction: row;
                justify-content: space-between;
            }
        }

        .github-buttons-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
        }

        footer a,
        footer button[data-npub] {
            color: #007bff;
            text-decoration: none;
            border: none;
            background: none;
            padding: 0;
            font: inherit;
        }

        footer a:hover,
        footer button[data-npub]:hover {
            text-decoration: none;
        }

        footer button[data-npub] {
            display: inline-block;
            height: 28px;
            padding: 5px 12px;
            font-size: 12px;
            font-weight: 600;
            color: #fff;
            background-color: #1a2026;
            border: 1px solid #3d444d;
            border-radius: 4px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            vertical-align: middle;
            margin-top: -4px;
        }

        footer button[data-npub]:hover {
            background-color: #1a2026;
            border-color: #3d444d;
        }

        footer button[data-npub]:active {
            background-color: #1e7e34;
            border-color: #1c7430;
        }

        .timeline-item {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .timeline-item p {
            margin: 0;
            font-size: 14px;
            line-height: 1.5;
        }

        .timeline-item small {
            color: #6c757d;
        }

        .reply-icon {
            bottom: 10px;
            left: 10px;
            cursor: pointer;
            color: #007bff;
            font-size: 18px;
            transition: color 0.3s ease;
        }

        .reply-icon:hover {
            color: indigo;
        }

        .timeline-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
        }

        .timeline-header .author {
            font-weight: bold;
            font-size: 16px;
            color: #333;
        }

        .timeline-header .timestamp {
            font-size: 12px;
            color: #888;
        }

        .reply-item {
            background-color: #fff;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
            position: relative;
            display: flex;
            flex-direction: column;
            gap: 10px;
        }

        .reply-item p {
            margin: 0;
            font-size: 14px;
            line-height: 1.5;
        }

        .reply-item small {
            color: #6c757d;
        }

        .reply-item .reply-icon {
            bottom: 10px;
            left: 10px;
        }

        .timeline-feed {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .replies-feed {
            display: flex;
            flex-direction: column-reverse;
            gap: 15px;
        }

        .send-button {
            width: 100%;
        }
    </style>
</head>

<body>
    <div class="sidebar">
        <!-- Hero Section -->
        <div class="hero-section">
            <img src="./images/anonostr-hero.png" alt="Anonostr Hero Banner" class="hero">
            <h1>Anonostr</h1>
        </div>
        <!-- Desc Section -->
        <div class="desc-section">
            <p>Send anonymous notes to the Nostr network without revealing
                your identity. Each note submission generates a new key pair that's securely burned after single use
                furthering anonymity.</p>
        </div>

        <form id="eventForm">
            <label for="note">Enter your note:</label>
            <textarea id="note" rows="6" placeholder="@npub1... or @note1... or #tag your note here"></textarea>

            <!-- Checkbox Group -->
            <div style="font-size: 12px; color: grey; margin-top: 10px; margin-bottom: 10px;">
                <strong>Optional:</strong>
            </div>
            <div class="checkbox-group">
                <div class="checkbox-container">
                    <input type="checkbox" id="replyChain">
                    <label for="replyChain">Reply chain</label>
                    <div class="tooltip">‚ÑπÔ∏è
                        <span class="tooltiptext">Enable this to link your notes as replies in a threaded conversation,
                            maintaining the context within a linked chain of notes.</span>
                    </div>
                </div>

                <div class="checkbox-container">
                    <input type="checkbox" id="relayHop">
                    <label for="relayHop">Relay hop</label>
                    <div class="tooltip">‚ÑπÔ∏è
                        <span class="tooltiptext">Relay hopping adds obfuscation by spreading notes across different
                            relays randomly, making it harder for any single relay to correlate and track the
                            notes.</span>
                    </div>
                </div>

                <div class="checkbox-container">
                    <input type="checkbox" id="torRelays">
                    <label for="torRelays">Tor relays</label>
                    <div class="tooltip">‚ÑπÔ∏è
                        <span class="tooltiptext">Use only relays behind onion services for added anonymity.</span>
                    </div>
                </div>
            </div>

            <button class="send-button" type="submit">
                Send Note
                <div class="spinner"></div>
            </button>

            <!-- Relay information display -->
            <div id="relayInfo" style="font-size: 12px; color: grey; margin-top: 10px;">
                <strong>Relays being used:</strong>
                <ul id="relayList"></ul>
            </div>
        </form>
        <div id="statusNote" class="note"></div>

        <!-- Footer Section -->
        <footer>
            <div class="github-buttons-container">
                <!-- "Zap Me ‚ö°Ô∏è" Button -->
                <button data-npub="npub16jdfqgazrkapk0yrqm9rdxlnys7ck39c7zmdzxtxqlmmpxg04r0sd733sv"
                    data-relays="wss://relay.damus.io,wss://relay.primal.net,wss://relay.nostr.band">
                    Zap Me ‚ö°Ô∏è
                </button>

                <!-- GitHub Button -->
                <a class="github-button" href="https://github.com/Spl0itable/Anonostr"
                    data-color-scheme="no-preference: light; light: light; dark: dark;" data-size="large"
                    aria-label="Follow @Spl0itable on GitHub">GitHub</a>

                <p>Made with üíü by <a
                        href="https://nostr.band/npub16jdfqgazrkapk0yrqm9rdxlnys7ck39c7zmdzxtxqlmmpxg04r0sd733sv"
                        target="_blank">@Lux</a></p>
        </footer>
    </div>

    <div class="main-content">
        <h2>Global</h2>
        <div class="timeline-feed" id="timelineFeed">
            <!-- Timeline items are dynamically injected here -->
        </div>
    </div>

    <div class="replies-column">
        <h2>Replies</h2>
        <div class="replies-feed" id="repliesFeed">
            <!-- Replies are dynamically injected here -->
        </div>
    </div>

    <!-- Service Worker Registration -->
    <script>
        if ('serviceWorker' in navigator) {
            navigator.serviceWorker.register('/service-worker.js')
                .then(registration => {
                    console.log('Service Worker registered with scope:', registration.scope);
                })
                .catch(error => {
                    console.log('Service Worker registration failed:', error);
                });
        }
    </script>

    <!-- Include nostr-tools Library -->
    <script src="https://unpkg.com/nostr-tools/lib/nostr.bundle.js"></script>

    <!-- GitHub Button Script -->
    <script async defer src="https://buttons.github.io/buttons.js"></script>

    <!-- Nostr Zap Button Script -->
    <script src="https://cdn.jsdelivr.net/npm/nostr-zap@1.1.0"></script>

    <script>
        document.addEventListener("DOMContentLoaded", () => {
            const statusNote = document.getElementById('statusNote');
            const form = document.getElementById('eventForm');
            const noteInput = document.getElementById('note');
            const replyChainCheckbox = document.getElementById('replyChain');
            const relayHopCheckbox = document.getElementById('relayHop');
            const torRelaysCheckbox = document.getElementById('torRelays');
            const submitButton = form.querySelector('button');
            const spinner = submitButton.querySelector('.spinner');
            const relayList = document.getElementById('relayList');
            const timelineFeed = document.getElementById('timelineFeed');
            const repliesFeed = document.getElementById('repliesFeed');

            // Default relays
            const defaultRelays = [
                'wss://relay.damus.io',
                'wss://relay.primal.net',
                'wss://relay.nostr.band'
            ];

            // Tor relays
            const torRelays = [
                'ws://oxtrdevav64z64yb7x6rjg4ntzqjhedm5b5zjqulugknhzr46ny2qbad.onion',
                'ws://2jsnlhfnelig5acq6iacydmzdbdmg7xwunm4xl6qwbvzacw4lwrjmlyd.onion',
                'ws://nostrnetl6yd5whkldj3vqsxyyaq3tkuspy23a3qgx7cdepb4564qgqd.onion'
            ];

            const rateLimitSeconds = 30; // 30-second delay between note sending
            const localStorageKey = 'lastSubmitTime';
            const eventIdsStorageKey = 'submittedEventIds'; // Key to store event IDs
            const seenEventIds = new Set(); // To track and deduplicate events

            let rootEventId = null; // Store the root event ID for threading
            let lastEventId = null; // Store the ID of the last event to reply to it in the chain

            // WebSocket references for managing subscriptions
            const wsRelays = {};

            function generateRandomHex(length) {
                const characters = '0123456789abcdef';
                let result = '';
                for (let i = 0; i < length; i++) {
                    const randomIndex = Math.floor(Math.random() * characters.length);
                    result += characters[randomIndex];
                }
                return result;
            }

            // Function to update the relay list display
            function updateRelayList() {
                relayList.innerHTML = ''; // Clear current list

                let selectedRelays;
                if (torRelaysCheckbox.checked) {
                    selectedRelays = torRelays;
                } else {
                    selectedRelays = defaultRelays;
                }

                // Populate the relay list
                selectedRelays.forEach(relayUrl => {
                    const relayItem = document.createElement('li');
                    relayItem.textContent = relayUrl;
                    relayList.appendChild(relayItem);
                });
            }

            // Event listeners to update relay list when the checkboxes change
            torRelaysCheckbox.addEventListener('change', updateRelayList);
            relayHopCheckbox.addEventListener('change', updateRelayList);

            // Initial invocation to show the correct relays on page load
            updateRelayList();

            form.addEventListener('submit', async (event) => {
                event.preventDefault();

                try {
                    const currentTime = Math.floor(Date.now() / 1000);
                    const lastSubmitTime = parseInt(localStorage.getItem(localStorageKey), 10) || 0;
                    const timeSinceLastSubmit = currentTime - lastSubmitTime;

                    if (timeSinceLastSubmit < rateLimitSeconds) {
                        const timeLeft = rateLimitSeconds - timeSinceLastSubmit;
                        showNote(`Please wait ${timeLeft} second(s) before submitting again.`, 'warning');
                        return;
                    }

                    // Reset the status note and show the spinner
                    showNote('', '');
                    spinner.style.display = 'inline-block';
                    submitButton.disabled = true;

                    // Generate a new key pair on each submit
                    const sk = NostrTools.generateSecretKey();
                    const pubKey = NostrTools.getPublicKey(sk);

                    let note = noteInput.value.trim();
                    if (!note) {
                        showNote('Please enter a note.', 'error');
                        resetFormState();
                        return;
                    }

                    const tags = [];
                    const bech32Regex = /@([a-z]{1,}[1][qpzry9x8gf2tvdw0s3jn54khce6mua7l]{6,})/g;

                    let isRootSet = false;
                    let firstMatchIsNote = false;

                    // Handle mentions and note references: @npub..., @nprofile..., @note...
                    const matches = note.match(bech32Regex);
                    if (matches) {
                        for (const match of matches) {
                            try {
                                // Decode the bech32 entity to get the hex key or ID
                                const decoded = NostrTools.nip19.decode(match.substring(1));
                                const hexKey = decoded.data;

                                if (decoded.type === 'note') {
                                    // If the @note... is at the beginning, treat it as a reply and don't convert it to nostr:note
                                    if (!isRootSet && note.startsWith(match)) {
                                        rootEventId = hexKey;
                                        tags.unshift(["e", hexKey, "", "root"]); // Ensure root event is first
                                        note = note.replace(match, '').trim();
                                        isRootSet = true;
                                        firstMatchIsNote = true;
                                    } else {
                                        // If @note... is not at the beginning, convert to nostr:note
                                        tags.push(["e", hexKey, "", "mention"]);
                                        note = note.replace(match, `nostr:${match.substring(1)}`);
                                    }
                                } else if (decoded.type === 'npub' || decoded.type === 'nprofile') {
                                    tags.push(["p", hexKey, "", "mention"]);
                                }
                            } catch (error) {
                                console.error('Error decoding bech32:', error);
                            }
                        }
                    }

                    // If reply chain is enabled and there's a last event ID, add it as a reply
                    if (replyChainCheckbox.checked && lastEventId) {
                        // Add the last event ID as the "reply"
                        tags.push(["e", lastEventId, "", "reply"]);

                        // Ensure the root event ID is included if it wasn't set above
                        if (rootEventId && !isRootSet) {
                            tags.unshift(["e", rootEventId, "", "root"]);
                            isRootSet = true;
                        }
                    }

                    // Handle hashtags: #tag
                    const hashtags = note.match(/#\w+/g);
                    if (hashtags) {
                        for (const tag of hashtags) {
                            tags.push(["t", tag.substring(1)]);
                        }
                    }

                    const eventTemplate = {
                        kind: 1,
                        pubkey: pubKey,
                        created_at: Math.floor(Date.now() / 1000),
                        tags: tags,
                        content: note
                    };

                    console.log('Event Template:', eventTemplate);

                    // Finalize the event (assigns the event ID, pubkey, and signs it)
                    const signedEvent = NostrTools.finalizeEvent(eventTemplate, sk);
                    lastEventId = signedEvent.id;

                    // Store the event ID in localStorage
                    saveEventId(lastEventId);

                    // If this is the first event, set it as the root for future replies
                    if (!rootEventId) {
                        rootEventId = lastEventId;
                    }

                    console.log('Signed Event:', signedEvent);

                    try {
                        let selectedRelays;

                        if (torRelaysCheckbox.checked) {
                            // Use Tor relays if the checkbox is checked
                            selectedRelays = torRelays;
                        } else {
                            // Otherwise, use default relays
                            selectedRelays = defaultRelays;
                        }

                        let relaySuccess = false;

                        if (relayHopCheckbox.checked) {
                            // If relay hop is checked, randomly select a single relay
                            let availableRelays = [...selectedRelays];

                            while (!relaySuccess && availableRelays.length > 0) {
                                const randomIndex = Math.floor(Math.random() * availableRelays.length);
                                const randomRelay = availableRelays[randomIndex];

                                const relayResult = await sendNoteToRelay(randomRelay, signedEvent);

                                if (relayResult.success) {
                                    relaySuccess = true;
                                    const eventId = signedEvent.id;
                                    const eventLink = `https://njump.me/${eventId}`;
                                    showNote(`Anon note sent successfully via relay hop! <a href="${eventLink}" target="_blank">View Event</a>`, 'success');
                                    noteInput.value = '';

                                    // Update the last submit time in localStorage only on success
                                    localStorage.setItem(localStorageKey, currentTime);

                                    // Renew subscriptions to include the new event ID
                                    renewReplySubscriptions();
                                } else {
                                    // Remove the failed relay from the list
                                    availableRelays.splice(randomIndex, 1);
                                    console.warn(`Relay hop failed for relay: ${randomRelay}. Trying another relay...`);
                                }
                            }

                            if (!relaySuccess) {
                                showNote('Relay hopping failed for all relays. Please try again later.', 'error');
                            }

                        } else {
                            // Otherwise, publish to all selected relays
                            const relayResults = await Promise.all(
                                selectedRelays.map(relayUrl => sendNoteToRelay(relayUrl, signedEvent))
                            );

                            const successfulRelays = relayResults.filter(result => result.success).length;

                            if (successfulRelays === 0) {
                                // If no relays were successful
                                showNote('No relays available. Please try again later.', 'error');
                            } else {
                                // Create a link to view the event on njump.me
                                const eventId = signedEvent.id;
                                const eventLink = `https://njump.me/${eventId}`;
                                showNote(`Anon note sent successfully via ${successfulRelays}/${selectedRelays.length} relays! <a href="${eventLink}" target="_blank">View Event</a>`, 'success');
                                noteInput.value = '';

                                // Update the last submit time in localStorage only on success
                                localStorage.setItem(localStorageKey, currentTime);

                                // Renew subscriptions to include the new event ID
                                renewReplySubscriptions();
                            }
                        }
                    } catch (error) {
                        console.error('Failed to send note:', error);
                        showNote('Failed to send anon note. Please try again.', 'error');
                    } finally {
                        // Reset the form state (hide spinner, enable button)
                        resetFormState();
                    }
                } catch (error) {
                    console.error('Error in form submission process:', error);
                    showNote('An unexpected error occurred. Please try again.', 'error');
                    resetFormState();
                }
            });

            function resetFormState() {
                spinner.style.display = 'none';
                submitButton.disabled = false;
            }

            function showNote(note, type) {
                statusNote.innerHTML = note;
                statusNote.className = `note ${type}`;
                statusNote.style.display = note ? 'block' : 'none';
            }

            async function sendNoteToRelay(relayUrl, event) {
                try {
                    const relay = new NostrTools.Relay(relayUrl);
                    await relay.connect();
                    await relay.publish(event);
                    relay.close();
                    return { success: true, relayUrl };
                } catch (error) {
                    console.error(`Failed to connect or publish to relay: ${relayUrl}`, error);
                    return { success: false, relayUrl };
                }
            }

            function createTimelineItem(event) {
                const timelineItem = document.createElement('div');
                timelineItem.className = 'timeline-item';

                const authorHex = event.pubkey;

                // Truncate the author's pubkey
                const truncatedAuthor = `${authorHex.slice(0, 6)}...${authorHex.slice(-4)}`;

                // Convert the Unix timestamp to a human-readable format
                const timestamp = new Date(event.created_at * 1000).toLocaleString();

                timelineItem.innerHTML = `
                <div class="timeline-header">
                    <span class="author">${truncatedAuthor}</span>
                    <span class="timestamp">${timestamp}</span>
                </div>
                <p>${event.content}</p>
                <span class="reply-icon" data-note-id="${event.id}">‚Ü©Ô∏è</span>
            `;

                const replyIcon = timelineItem.querySelector('.reply-icon');
                replyIcon.addEventListener('click', () => {
                    // Set the rootEventId and update the note input
                    rootEventId = replyIcon.getAttribute('data-note-id');
                    noteInput.value = `@${NostrTools.nip19.noteEncode(rootEventId)} ` + noteInput.value;
                    noteInput.focus();
                });

                return timelineItem;
            }

            function createReplyItem(event) {
                const replyItem = document.createElement('div');
                replyItem.className = 'reply-item';

                const authorHex = event.pubkey;

                // Truncate the author's pubkey
                const truncatedAuthor = `${authorHex.slice(0, 6)}...${authorHex.slice(-4)}`;

                // Convert the Unix timestamp to a human-readable format
                const timestamp = new Date(event.created_at * 1000).toLocaleString();

                replyItem.innerHTML = `
                <div class="timeline-header">
                    <span class="author">${truncatedAuthor}</span>
                    <span class="timestamp">${timestamp}</span>
                </div>
                <p>${event.content}</p>
                <span class="reply-icon" data-note-id="${event.id}">‚Ü©Ô∏è</span>
            `;

                const replyIcon = replyItem.querySelector('.reply-icon');
                replyIcon.addEventListener('click', () => {
                    // Set the rootEventId and update the note input
                    rootEventId = replyIcon.getAttribute('data-note-id');
                    noteInput.value = `@${NostrTools.nip19.noteEncode(rootEventId)} ` + noteInput.value;
                    noteInput.focus();
                });

                return replyItem;
            }

            function subscribeToRelay(relayUrl) {
                if (wsRelays[relayUrl]) {
                    console.log(`Already subscribed to ${relayUrl}`);
                    return;
                }

                const ws = new WebSocket(relayUrl);
                wsRelays[relayUrl] = ws;

                ws.onopen = () => {
                    console.log(`Connected to relay: ${relayUrl}`);

                    // Send a REQ message to subscribe to text notes (kind 1) with a limit of 100 events
                    const subscriptionId = generateRandomHex(32);
                    const reqMessage = JSON.stringify([
                        "REQ",
                        subscriptionId,
                        { kinds: [1], limit: 100 } // Add the limit filter here
                    ]);
                    ws.send(reqMessage);
                    console.log(`Subscribed to relay ${relayUrl} with message: ${reqMessage}`);
                };

                ws.onmessage = (event) => {
                    const msg = JSON.parse(event.data);
                    if (msg[0] === "EVENT") {
                        const nostrEvent = msg[2];
                        if (!seenEventIds.has(nostrEvent.id)) {
                            seenEventIds.add(nostrEvent.id);
                            const newTimelineItem = createTimelineItem(nostrEvent);

                            timelineFeed.prepend(newTimelineItem); // Always prepend to show newest at the top
                        }
                    }
                };

                ws.onerror = (error) => {
                    console.error(`Error with relay ${relayUrl}:`, error);
                };

                ws.onclose = () => {
                    console.log(`Disconnected from relay: ${relayUrl}`);
                    delete wsRelays[relayUrl];
                };
            }

            function subscribeToRepliesInitialLoad(relayUrl, eventIds) {
                const ws = new WebSocket(relayUrl);
                wsRelays[relayUrl] = ws;

                ws.onopen = () => {
                    console.log(`Connected to relay for replies: ${relayUrl}`);
                    sendReplySubscription(ws, eventIds);
                };

                ws.onmessage = (event) => {
                    const msg = JSON.parse(event.data);
                    if (msg[0] === "EVENT") {
                        const nostrEvent = msg[2];
                        if (!seenEventIds.has(nostrEvent.id)) {
                            seenEventIds.add(nostrEvent.id);
                            const newReplyItem = createReplyItem(nostrEvent);

                            // Append the new reply to the bottom of the replies feed
                            repliesFeed.append(newReplyItem);
                        }
                    }
                };

                ws.onerror = (error) => {
                    console.error(`Error with relay ${relayUrl} for replies:`, error);
                };

                ws.onclose = () => {
                    console.log(`Disconnected from relay: ${relayUrl}`);
                    // Reconnect to maintain the subscription for real-time updates
                    setTimeout(() => {
                        subscribeToRepliesInitialLoad(relayUrl, eventIds);
                    }, 3000); // Reconnect after 3 seconds
                };
            }

            function subscribeToRepliesUpdate(relayUrl, eventIds) {
                if (wsRelays[relayUrl]) {
                    console.log(`Already subscribed to ${relayUrl} for replies`);

                    // Ensure the WebSocket is open before sending the request
                    if (wsRelays[relayUrl].readyState === WebSocket.OPEN) {
                        sendReplySubscription(wsRelays[relayUrl], eventIds);
                    } else if (wsRelays[relayUrl].readyState === WebSocket.CONNECTING) {
                        // If the WebSocket is still connecting, wait until it's open
                        wsRelays[relayUrl].addEventListener('open', () => {
                            sendReplySubscription(wsRelays[relayUrl], eventIds);
                        }, { once: true });
                    }
                    return;
                }

                console.log(`WebSocket not connected to ${relayUrl}. Connecting...`);

                const ws = new WebSocket(relayUrl);
                wsRelays[relayUrl] = ws;

                ws.onopen = () => {
                    console.log(`Connected to relay for replies: ${relayUrl}`);
                    sendReplySubscription(ws, eventIds);
                };

                ws.onmessage = (event) => {
                    const msg = JSON.parse(event.data);
                    if (msg[0] === "EVENT") {
                        const nostrEvent = msg[2];
                        if (!seenEventIds.has(nostrEvent.id)) {
                            seenEventIds.add(nostrEvent.id);
                            const newReplyItem = createReplyItem(nostrEvent);
                            // Append the new reply to the bottom of the replies feed
                            repliesFeed.append(newReplyItem);
                        }
                    }
                };

                ws.onerror = (error) => {
                    console.error(`Error with relay ${relayUrl} for replies:`, error);
                };

                ws.onclose = () => {
                    console.log(`Disconnected from relay: ${relayUrl}`);
                    // Reconnect to maintain the subscription for real-time updates
                    setTimeout(() => {
                        subscribeToRepliesUpdate(relayUrl, eventIds);
                    }, 3000); // Reconnect after 3 seconds
                };
            }

            function sendReplySubscription(ws, eventIds) {
                const subscriptionId = generateRandomHex(32);
                const reqMessage = JSON.stringify([
                    "REQ",
                    subscriptionId,
                    {
                        kinds: [1], // Text notes
                        '#e': eventIds, // Filter by event ID tags (replies)
                        limit: 100 // Add the limit filter here
                    }
                ]);

                // Send the REQ message to the WebSocket
                ws.send(reqMessage);

                // Log after sending the message
                console.log(`Updated subscription to relay for replies with message: ${reqMessage}`);
            }

            function fetchTimeline() {
                for (const relayUrl of defaultRelays) {
                    subscribeToRelay(relayUrl); // Prepend items to the top
                }
            }

            function fetchReplies() {
                const eventIds = getSavedEventIds();
                if (eventIds.length === 0) {
                    console.log('No event IDs found to fetch replies for.');
                    return;
                }

                for (const relayUrl of defaultRelays) {
                    subscribeToRepliesInitialLoad(relayUrl, eventIds); // Prepend items to the top
                }
            }

            // Save event IDs in localStorage
            function saveEventId(eventId) {
                let eventIds = JSON.parse(localStorage.getItem(eventIdsStorageKey)) || [];
                eventIds.push(eventId);
                localStorage.setItem(eventIdsStorageKey, JSON.stringify(eventIds));
            }

            // Get saved event IDs from localStorage
            function getSavedEventIds() {
                return JSON.parse(localStorage.getItem(eventIdsStorageKey)) || [];
            }

            // Renew subscriptions to include newly saved event IDs
            function renewReplySubscriptions() {
                const eventIds = getSavedEventIds();
                if (eventIds.length === 0) return;

                // Close existing connections to relays and reopen them
                for (const relayUrl of defaultRelays) {
                    if (wsRelays[relayUrl]) {
                        wsRelays[relayUrl].close();
                    }
                    subscribeToRepliesUpdate(relayUrl, eventIds);
                }
            }

            // Fetch the timeline and replies on page load
            fetchTimeline();
            fetchReplies();
        });
    </script>
</body>

</html>